name: Deploy Server Service
on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  NETWORK: 'prod_swecc-network'
  CPU_LIMIT: '0.3'
  MEMORY_LIMIT: '256M'
  CPU_RESERVE: '0.1'
  MEMORY_RESERVE: '128M'
  DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  CONFIG_NAME: 'server_env'

jobs:
  filter:
    runs-on: ubuntu-latest
    outputs:
      swecc_server: ${{ steps.filter.outputs.swecc-server }}
      rabbit_listener: ${{ steps.filter.outputs.swecc-server-rabbit-listener }}
    steps:
      - name: Check changed files
        id: filter
        uses: dorny/paths-filter@v2
        with:
          filters: |
            swecc-server:
              - '!server/rabbitmq_listener.py'
            swecc-server-rabbit-listener:
              - 'server/rabbitmq_listener.py'

  push_to_dockerhub:
    needs: filter
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ['swecc-server', 'swecc-server-rabbit-listener']

    steps:
      - name: Check if this service should run
        run: |
          if [[ "${{ matrix.image }}" == "service1" && "${{ needs.filter.outputs.swecc_server }}" == "true" ]]; then
            echo "Deploying swecc-server"
          elif [[ "${{ matrix.image }}" == "service2" && "${{ needs.filter.outputs.rabbit_listener }}" == "true" ]]; then
            echo "Deploying swecc-server-rabbit-listener"
          else
            echo "Skipping ${{ matrix.image }}"
            # Dynamically skip a job
            exit 78
          fi
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Log in to Docker Hub
        uses: docker/login-action@v1
        with:
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v2
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKERHUB_USERNAME }}/${{ matrix.IMAGE }}:latest
            ${{ env.DOCKERHUB_USERNAME }}/${{ matrix.IMAGE }}:${{ github.sha }}

  deploy_to_swarm:
    runs-on:
      group: EC2
      labels: [self-hosted, deploy]

    needs: push_to_dockerhub
    strategy:
      matrix:
        image: ['swecc-server', 'swecc-server-rabbit-listener']
        include:
          - image: 'swecc-server'
            service_name: 'server'
          - image: 'swecc-server-rabbit-listener'
            service_name: 'rabbitmq-host'

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Login to Docker Hub on deployment server
        uses: docker/login-action@v1
        with:
          username: ${{ env.DOCKERHUB_USERNAME }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Pull latest image
        run: |
          docker pull ${{ env.DOCKERHUB_USERNAME }}/${{ matrix.image }}:latest

      - name: Prepare environment file
        run: |
          echo "Parsing environment variables..."
          docker config inspect ${{ env.CONFIG_NAME }} --pretty | sed -n '/Data:/,$ p' | sed '1d' > env_file.txt || echo "No config found"

      - name: Check for existing service
        id: check_service
        run: |
          if docker service ls | grep -q "${{ matrix.service_name }}"; then
            echo "existing_service=true" >> $GITHUB_OUTPUT
          else
            echo "existing_service=false" >> $GITHUB_OUTPUT
          fi

      - name: Create staging service for zero-downtime deployment
        id: create_staging
        if: steps.check_service.outputs.existing_service == 'true'
        run: |
          STAGING_NAME="${{ matrix.service_name }}-staging"

          echo "Creating temporary service: $STAGING_NAME"
          docker service create \
            --name "$STAGING_NAME" \
            --network ${{ env.NETWORK }} \
            --env-file env_file.txt \
            --replicas 1 \
            --restart-condition any \
            --limit-cpu ${{ env.CPU_LIMIT }} \
            --limit-memory ${{ env.MEMORY_LIMIT }} \
            --reserve-cpu ${{ env.CPU_RESERVE }} \
            --reserve-memory ${{ env.MEMORY_RESERVE }} \
            --with-registry-auth \
            ${{ env.DOCKERHUB_USERNAME }}/${{ matrix.image }}:latest

          echo "New service is healthy - promoting staging service to production"
          docker service update \
            --update-parallelism 1 \
            --hostname ${{ matrix.service_name }} \
            $STAGING_NAME

          echo "Removing old service"
          docker service rm ${{ matrix.service_name }}

          echo "staging_success=true" >> $GITHUB_OUTPUT

      - name: Create new service
        if: steps.check_service.outputs.existing_service == 'false' || steps.create_staging.outputs.staging_success == 'true'
        run: |
          echo "Creating new prod service for ${{ matrix.service_name }}"
          docker service create \
            --name ${{ matrix.service_name }} \
            --network ${{ env.NETWORK }} \
            --env-file env_file.txt \
            --replicas 1 \
            --restart-condition any \
            --update-parallelism 1 \
            --update-delay 30s \
            --update-order start-first \
            --update-failure-action continue \
            --limit-cpu ${{ env.CPU_LIMIT }} \
            --limit-memory ${{ env.MEMORY_LIMIT }} \
            --reserve-cpu ${{ env.CPU_RESERVE }} \
            --reserve-memory ${{ env.MEMORY_RESERVE }} \
            --with-registry-auth \
            ${{ env.DOCKERHUB_USERNAME }}/${{ matrix.image }}:latest

      - name: Cleanup
        run: |
          docker service rm ${{ matrix.service_name }}-staging || true
          rm env_file.txt || true
